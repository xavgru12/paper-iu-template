@report{parser,
   title = {Memory-Based Parsing},
   year = {2004},
}
@report{scheduler,
   abstract = {[ 44 ] Process schedulers The effectiveness of any operating system is proportional to its ability to fairly schedule all contending processes. The process scheduler is the core component of the kernel, which computes and decides when and for how long a process gets CPU time. Ideally, processes require a timeslice of the CPU to run, so schedulers essentially need to allocate slices of processor time fairly among processes. A scheduler typically has to: Avoid process starvation Manage priority scheduling Maximize throughput of all processes Ensure low turnaround time Ensure even resource usage Avoid CPU hogging Consider process' behavioral patterns for prioritization Elegantly subsidize under heavy load Handle scheduling on multiple cores efficiently Linux process scheduler design Linux, which was primarily developed for desktop systems, has unassumingly evolved into a multi-dimensional operating system with its usage spread across embedded devices, mainframes, and supercomputers to room-sized servers. It has also seamlessly accommodated the ever-evolving diverse computing platforms such as SMP, virtualization, and real-time systems. The diversity of these platforms is brought forth by the kind of processes that run on these systems. For instance, a highly interactive desktop system may run processes that are I/O bound, and a real-time system thrives on deterministic processes. Every kind of process thus calls for a different kind of heuristic when it needs to be fairly scheduled, as a CPU-intensive process may require more CPU time than a normal process, and a real-time process would require deterministic execution. Linux, which caters to a wide spectrum of systems, is thus confronted with addressing the varying scheduling challenges that come along when managing these diverse processes.},
   title = {Deciphering the Process Scheduler},
   year = {2017},
}
@web_page{hilwikipedia,
   abstract = {Hardware in the Loop (HiL, auch HIL, HitL, HITL) bezeichnet ein Verfahren, bei dem ein eingebettetes System (z. B. reales elektronisches Steuergerät oder reale mechatronische Komponente, die Hardware) über seine Ein-und Ausgänge an ein angepasstes Gegenstück angeschlossen und getestet wird. Letzteres heißt im Allgemeinen HiL-Simulator und dient als Nachbildung der realen Umgebung des Systems. Hardware in the Loop ist aus Sicht des Tests eine Methode zum Absichern von eingebetteten Systemen, zur Unterstützung während der Entwicklung sowie zur vorzeitigen Inbetriebnahme von Maschinen und Anlagen. Wird nicht die Zielhardware eingesetzt und lediglich eine Simulation der Software durchgeführt, spricht man von Software in the Loop.},
   title = {Hardware in the Loop - Wikipedia Eintrag},
   url = {https://de.wikipedia.org/wiki/Hardware_in_the_Loop},
}
@article{fehler,
   title = {Die größten Kostenfallen - AP Verlag},
}
@article{tptwikipedia,
   title = {TPT - Wikipedia Eintrag},
}
@web_page{piketecwebseite,
   title = {Piketec Webseite},
   url = {https://piketec.com/de/tpt/},
}
@report{dynamischeanalyse2,
   title = {Statische Analyse und Dynamischer Test: Wo liegen die Stärken und Schwächen?},
   url = {https://heicon-ulm.de/statische-analyse-und-dynamischer-test-wo-liegen-die-staerken-und-schwaechen/},
}
@article{dynamischeanalyse1,
   title = {DynamischeAnalyse1},
}
@book{java,
   author = {Christian Ullenboom},
   title = {Java ist auch eine Insel},
}
@web_page{eigequi2,
   abstract = {Volumes 4-10 published by Kluwer Academic Publishers. Volume 10 is a subject and author index. V.1. A-B v.2. C v.3. D-Feynman Measure. v.4. Fibonaccimethod H v.5. Lituus v.6. Lobachevskii Criterion (for Convergence)-Optical Sigman-Algebra. v.7. Orbit-Rayleigh Equation. v.8. Reaction-Diffusion Equation-Stirling Interpolation Formula. v.9. Stochastic Approximation-Zygmund Class of Functions. v.10. Subject Index-Author Index. V. 1. A -- B -- v. 2. C -- v. 3. D -- Fey -- v. 4. Fib -- H -- v. 5. I -- Lit -- v. 6. Lob -- Opt -- v. 7. Orb -Ray -- v. 8. Rea -- Sti -- v. 9. Sto -- Zyg -- v. 10 Subject Index -- Author Index.},
   author = {Michiel. Hazewinkel},
   isbn = {9781556080104},
   publisher = {Reidel},
   title = {Encyclopaedia of mathematics : an updated and annotated translation of the Soviet "Mathematical encyclopaedia"},
   year = {1988},
}
@web_page{eigequi1,
   title = {Theoretische Informatik},
   url = {www.theoretische-informatik.com/relationen},
}
@book{integration,
   author = {Lars Borner},
   title = {Integrations-Test},
   url = {www.hanser-fachbuch.de/newsletter},
   year = {2022},
}
@book{agiletesting,
   author = {Marie Walsh},
   title = {Agile Testing Foundations},
   url = {http://shop.bcs.org/},
   year = {2017},
}
@report{silest,
   abstract = {Das diesem Bericht zugrunde liegende Projekt wurde mit Mitteln des Bundesministeriums für Bildung und Forschung unter dem Förderkennzeichen 01ISC12A gefördert. Die Verantwortung für den Inhalt der Veröffentlichung liegt bei den Autoren.},
   author = {Jens Geppert},
   title = {Abschlussbericht des Projekts SiLEST (Software in the Loop for Embedded Software Test) in der BMBF-Forschungsoffensive},
   year = {2004},
}
@article{tpttutorial,
   author = {TPT},
   title = {TPT Tutorial},
}
@web_page{tptsut,
   abstract = {The input and output signals are correlated from the perspecve of SUT or TPT. TPT or SUT synchronous test execuon influences the data logging during test execuon, which may affect the test assessments. Select Options|Preferences|TPT Model Behavior and switch between the SUT or TPT perspecve. The SUT perspecve is recommended. SUT synchronous test execuon In the following secon both perspecves are described in detail. General Test cases generated in TPT are connected to the SUT in a loop as shown below. Loop of test cases in TPT and SUT TPT and the SUT exchange data via signal connecons. That is, a test case which is in charge of generang appropriate signal values, writes these signal values in the TPT output. The TPT output is connected to the input of the SUT. The SUT reads the signal values generated by TPT and evaluates the related response at exactly the same me as receiving the input data. The SUT sends the response to the TPT input. TPT reads the result of the SUT calculaons in the next cycle. This interacon is repeated as it is shown in the following figure:},
   author = {TPT},
   title = {TPT/SUT Test Execution},
   url = {https://files.piketec.com/downloads/releases/TPT17/manuals/Content/Test},
}
@report{userguide,
   author = {TPT},
   title = {User Guide},
   url = {www.piketec.com},
}
@web_page{zf,
   title = {ZF Webseite},
   url = {https://www.zf.com/mobile/de/company/company.html},
}
@book{equimaths,
   author = {Siegfried Bosch},
   city = {Berlin, Heidelberg},
   doi = {10.1007/978-3-642-55260-1},
   isbn = {978-3-642-55259-5},
   publisher = {Springer Berlin Heidelberg},
   title = {Lineare Algebra},
   url = {http://link.springer.com/10.1007/978-3-642-55260-1},
   year = {2014},
}
@report{tpt,
   author = {Eckard Lehmann},
   title = {Time Partition Testing-Systematischer Test des kontinuierlichen Verhaltens von eingebetteten Systemen},
   year = {2003},
}
@report{equiinformatic,
   title = {Basiswissen Softwaretest},
   url = {http://ebookcentral.proquest.com/lib/fhws/detail.action?docID=1049740.},
}
